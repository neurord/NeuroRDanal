#sig2_60s.py
#Process text files generated by sig.py to extract time samples (features) for discriminant analysis
#ARGS="subdir/fileroot,LTPmol,LTDmol,tstart tend, sample dur, sample times"
#ARGS="Model_SPNspineAChm4R_Gshydr5_GapD,Aphos CKpCam Epac1 Pkc,2ag,10 20,"
#ARGS="Model_SPNspineAChm4R_Gshydr5_GapD,Aphos CKpCam Epac1 Pkc,2ag,10 20,30 60,"
#ARGS="Model_SPNspineAChm4R_Gshydr5_GapD,Aphos CKpCam Epac1 Pkc,2ag,10 20,30 60,60 120"
from __future__ import print_function
from __future__ import division

import os
import numpy as np
from matplotlib import pyplot
import sys  
import glob
from NeuroRDanal import h5utils_subset as h5utils

#specify either 'mean' or column numbers, or region names
#coltype=[1,2,3,4,5,6]
coltype=['nonspine','sa1[0]','sa1[1]','sa1[2]','sa1[3]','sa1[4]','sa1[5]','sa1[6]','sa1[7]','sa1[8]','sa1[9]']
trials=3 #make trials=1 if coltype=='mean'
normYN=0
textsize=8
plotYN=0
print_measures=0

try:
    args = ARGS.split(",")
    print("ARGS =", ARGS, "commandline=", args)
    do_exit = False
except NameError: #NameError refers to an undefined variable (in this case ARGS)
    args = sys.argv[1:]
    print("commandline =", args)
    do_exit = True

#Identify set of filenames and parameter values
fnames = glob.glob(args[0]+"*plas.txt")
print(args[0]+"*plas.txt, ", len(fnames), 'files found')
fname_roots=sorted(set([fnm[0:fnm.rfind('_')] for fnm in fnames]))
fname_endings=set([fnm[fnm.rfind('_'):] for fnm in fnames])
parval=[fnm[fnm.find('-')+1:].replace('-',' ') for fnm in fname_roots]

#assign other inputs (args) to parameters
ltp_molecules=args[1].split()
ltd_molecules=args[2].split()
tstart,tend=args[3].split()
if len(args[4]):
    time_thresh=args[4].split()
else:
    time_thresh=[60,30] #units are sec.
    if len(args[5]):
        samp_times=args[5].split()
    else:
        samp_times=[60,120]

all_molecules=sorted(ltp_molecules+ltd_molecules)
num_mols=len(all_molecules)

#Read in all files and assemble relevant columns into large data matrix
all_peaks={}
all_sig_array={}
for molnum,mol in enumerate(all_molecules):
    for fnum,fname in enumerate(fname_roots):
        fnm=fname+'_'+mol+'plas.txt'
        f = open(fnm, 'r+')
        header=f.readline()
        f.close()
        head_names=header.split()
        temp=[]
        if coltype=='mean':
            col_num=[head_names.index(x) for x in head_names if coltype in x][0:-1]
        elif type(coltype) is list and type(coltype[0]) is str:
            for col in coltype:
                temp.append([head_names.index(x) for x in head_names if '_t' in x and col in x])
            col_num=[val for sublist in temp for val in sublist]
            print (col_num)
        else:
            col_num=coltype
        alldata=np.loadtxt(fnm,skiprows=1)
        time=alldata[:,0]
        data_cols=alldata[:,col_num]
        #very specific kluge because one of the files started much later. 
        if fname.split('-')[-1]=='blockPKA' or fname.split('-')[-1]=='blockPKA2':
            extra=int(30/time[1])
        else:
            extra=0
        pstrt=int(int(tstart)/time[1])
        pend=int(int(tend)/time[1])
        if fnum==0:
            sig_array=np.zeros((len(fname_roots),len(time),len(col_num)))
            peaks=np.zeros((len(fname_roots),len(col_num)))
        #
        ########################### Signature part ##########################
        #
        #optionally normalize by subtracting baseline
        if normYN:
            basal=np.mean(data_cols[pstrt+extra:pend+extra],axis=0)
        else:
            basal=np.zeros(len(col_num))
        if np.shape(data_cols[extra:,:])[0]<np.shape(sig_array)[1]:
            print (fname,'zero padding end by', extra*time[1])
            sig_array[fnum]=np.pad(data_cols[extra:,:],((0,extra),(0,0)),mode='constant')-basal
        else:
            sig_array[fnum]=data_cols[extra:,:]-basal
        peaks[fnum]=np.max(sig_array[fnum],axis=0)
    all_sig_array[mol]=sig_array
    all_peaks[mol]=peaks
#
# Include baseline to be able to use amount above or ratio above baseline. 
# Place the following into function 
for dur in time_thresh:  
    samplepoints=[(pstrt,pend)] 
    win=int(dur/time[1]/2) 
    for st in [samp_times]: 
 	t=int(st/time[1])+pstrt-win
        #samplepoints=[(pstrt,pend),(t,t+2*win)] #alt2 - if multiple sample points, create multiple files
	samplepoints.append((t,t+2*win)) #alt 1 - if multiple sample points, create single file with multiple points
	#
	header='filename trial '
        sample_strings=[str(int(st[0]*dt[1])) for st in samplepoints[1:]]
        sample_str='_'+'and'.join(sample_strings)+'_'
	outfname=fname_roots[0].split('-')[0]+sample_str+str(dur)+'.txt'
	f=open(outfname, 'w')
        #
	#This for tr in range(trials) and colset=[col*trials+tr for col in range(num_regions)] is specific to sig.py output format
	num_regions=int(len(col_num)/trials)
	for fnum,fname in enumerate(fname_roots):
	    for tr in range(trials):
		colset=[col*trials+tr for col in range(num_regions)]
		samples=[]
		for mol in sorted(all_sig_array.keys()):
                    #print(fname,mol)
		    for t,samp_point in enumerate(samplepoints):
			if fnum==0 and tr==0:
			    for col in range(num_regions):
				header=header+str(mol)+'_'+str(int((samp_point[0]+samp_point[1])*0.5*time[1]))+'c'+str(col)+' '
			extracted_data=all_sig_array[mol][fnum][samp_point[0]:samp_point[1]].T
			samples.append(list(np.mean(extracted_data[colset],axis=1)))
		if fnum==0 and tr==0:
		    f.write(header+'\n')
		outputrow=[ np.round(val,2) for sublist in samples for val in sublist]
		out=str(tr)+' '+" ".join(str(e) for e in outputrow)
		f.write(fname[fname.find('-'):]+' '+out+'\n')
	    #print(fname,out)
	f.close()
